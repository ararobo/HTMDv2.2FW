@startuml motor_driver_architecture

namespace gn10_motor {

    class Config {
        - pid_kp : float
        - pid_ki : float
        - pid_kd : float
        - max_velocity : float
        - max_acceleration : float
        - control_loop_dt_ms : int
        + get_pid_kp() : float
        + get_pid_ki() : float
        + get_pid_kd() : float
        + get_max_velocity() : float
        + get_max_acceleration() : float
        + get_control_loop_dt_ms() : int
        + set_pid_kp(kp: float) : void
        + set_pid_ki(ki: float) : void
        + set_pid_kd(kd: float) : void
        + set_max_velocity(max_vel: float) : void
        + set_max_acceleration(max_acc: float) : void
    }

    class MotorController {
        - motor_ : interfaces.MotorInterface&
        - encoder_ : interfaces.EncoderInterface&
        - params_ : Config&
        + init()
        + update()
    }

    class AccelerationLimiter {
        + limit(current_val: float, target_val: float, dt: float) : float
    }

    class PID {
        + calculate(target: float, feedback: float, dt: float) : float
    }

    namespace interfaces {
        interface MotorInterface {
            + {abstract} set_duty_cycle(duty: float) : void
            + {abstract} set_short_brake(enabled: bool) : void
            + {abstract} ~MotorInterface()
        }

        interface EncoderInterface {
            + {abstract} update() : void
            + {abstract} get_velocity_rad_s() : float
            
            ' 積算角度（相対角）：起動時0スタート
            + {abstract} get_relative_angle_rad() : float
            
            ' 絶対角度：非対応ならfalseを返す
            + {abstract} try_get_absolute_angle_rad(out angle: float&) : bool
            + {abstract} has_absolute_position() : bool
            
            + {abstract} ~EncoderInterface()
        }

        interface IndicatorInterface {
            + {abstract} set_state(state: State) : void
            + {abstract} heartbeat() : void
            + {abstract} ~IndicatorInterface()
        }

        enum State {
            INITIALIZED
            RUNNING
            ERROR
        }
    }

    MotorController *-- AccelerationLimiter
    MotorController *-- PID
    MotorController o-- interfaces.MotorInterface
    MotorController o-- interfaces.EncoderInterface
    MotorController o-- Config
    IndicatorInterface o-- State
}

namespace targets {
    namespace common {
        ' インターフェースを具体的に継承(実体化)
        class STM32Motor implements gn10_motor.interfaces.MotorInterface {
            - timer_ : TIM_HandleTypeDef*
            - channel : uint32_t
        }

        class STM32Encoder implements gn10_motor.interfaces.EncoderInterface {
            - timer_ : TIM_HandleTypeDef*
        }

        class STM32Indicator implements gn10_motor.interfaces.IndicatorInterface {
            - port : GPIO_TypeDef*
            - pin : uint16_t
        }
    }

    ' main.cppに相当するパッケージ
    package stm32xxx_main {
        
        class MainLoop << (S,#FF7700) static >> {
            - motor : STM32Motor
            - encoder : STM32Encoder
            - controller : MotorController
            - params : Config
            - indicator : STM32Indicator
            - can_bus : external.gn10_can.core.CANBus
            - can_device : external.gn10_can.devices.MotorDriver
            + main()
        }

        class DriverSTM32CAN {
            + init()
        }
        
        MainLoop ..> gn10_motor.MotorController : "instantiates & updates"
        MainLoop ..> targets.common.STM32Motor : "instantiates"
        MainLoop ..> targets.common.STM32Indicator : "instantiates"
        MainLoop ..> targets.common.STM32Encoder : "instantiates"
        MainLoop ..> DriverSTM32CAN : "instantiates"
    }
}

targets.stm32xxx_main.MainLoop ..> external.gn10_can.devices.MotorDriver : "instantiates"
targets.stm32xxx_main.MainLoop ..> external.gn10_can.core.CANBus : "instantiates"

package external {
    namespace gn10_can {

        namespace core {
            struct CANFrame {
                + id
                + data
                + dlc
                + flags
            }

            class CANBus {
                - attach(device)
                - detach(device)
                + update()
                + send_frame(frame)
            }

            abstract class CANDevice {
                + {abstract} on_receive(frame)
                # send(command, data)
            }
        }

        namespace drivers {
            interface DriverInterface {
                + {abstract} send(frame)
                + {abstract} receive(out_frame)
            }
        }

        namespace devices {
            class MotorDriver {
                + send_init(config)
                + send_target(target)
                + send_gain(type, value)
                + on_receive(frame)
            }

            class MotorConfig {
                + set_params(...)
                + to_bytes()
            }
        }

        core.CANBus o-- drivers.DriverInterface
        core.CANBus "1" o-- "*" core.CANDevice : manages (RAII) >
        core.CANDevice <|-- devices.MotorDriver
        core.CANDevice ..> core.CANBus : attaches to >
        devices.MotorDriver ..> devices.MotorConfig : uses >
    }
}
@enduml